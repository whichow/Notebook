> 正如我在之前的博客文章[Unit testing part 1 – Unit tests by the book](http://blogs.unity3d.com/2014/05/21/unit-testing-part-1-unit-tests-by-the-book/)中承诺的那样，这篇文章致力于设计具有可测试性的*MonoBehaviours*。 *MonoBehaviour*是一种由Unity以特殊方式处理的特殊类。每次尝试实例化*MonoBehaviour*派生类时，都会收到一条警告不允许这样做。做一个好孩子并且不要忽视这个警告（忽视警告从长远来看是不好的！）你可能会问自己这个问题，那么我该如何模拟*MonoBehaviour*呢？好消息是你不必这样做！让我来介绍… 

## 谦卑对象(Humble Object)模式

如果你已经尝试编写测试，那么你可能偶然发现了一些单元测试的天敌，如UI，遗留代码，没有源码的糟糕设计或高并发的地方。什么使得这些部分难以测试？实现隔离：从上下文中分离正在测试的内容。有些工具对遗留代码有用，但对于新代码，可以使用一个非常简单的模式：谦虚对象模式。 

这种模式背后的想法非常简单。无论何时你想测试一个组件有任何难以测试的依赖关系，将该组件中的所有逻辑提取到一个单独的，解耦的（因此可测试的）类，然后引用它。换句话说，有问题的组件（带有使测试者的生活变得悲惨的依赖关系）变成了一个非常薄的代码层，它拥有尽可能少的逻辑代码，并且所有的逻辑操作都委托给新创建的类。 

从一个有间接依赖的测试到不可测试的组件状态... 

![example-dependancy1](https://blogs.unity3d.com/wp-content/uploads/2014/06/example-dependancy11.png) 

......我们进入了一种测试甚至不知道糟糕的（不可测的）代码的状态： 

![example-dependancy2](https://blogs.unity3d.com/wp-content/uploads/2014/06/example-dependancy21.png) 

有很多工作要做。老实说，这是一件不容易的事情。 

## 游戏对于可测试性

什么让游戏在代码和可测试性方面如此特别？测试游戏与测试其他软件有什么不同？就我个人而言，我认为游戏是一个非常复杂的软件。如果说游戏与你每天使用的软件没有太大差别，那就太天真了。在游戏中（当然有例外），你会发现闪亮和精美的图形，背景音乐和其他精心设计的音效。游戏通常需要处理来自各种来源的实时输入，以及一系列输出设备（读取分辨率）。游戏的非功能性要求也可能更严格。多人游戏需要您拥有可靠的同步网络连接，同时保持您保持恒定帧速所需的性能。 

这可以形成一个涉及许多不同媒体和技术的复杂系统。对我而言，游戏始终是软件终端产品的杰作，其中有些可以被视为艺术作品（以古典，视觉方式以及技术，幕后方面）。 

## Unity对于可测试性

所有这些复杂性对代码体系结构都有影响。对于我们来说的不幸的是，高性能架构通常会违反良好的代码设计，这个限制你在Unity中也可能会遇到。 其中的一个核心机制以特殊的方式设计，就是*MonoBehaviours*机制。如果你想知道为什么*MonoBehaviours*中的回调没有通过接口或继承来实现（就像我们通常想象的），~~这是出于性能方面的考虑~~（参见Lucas Meijer在评论中的说明）。没有深入细节，这也违背了*MonoBehaviours*的可测性。事实上，你不能用new操作符实例化*MonoBehaviour*几乎不允许你使用任何模拟框架。无论如何，每当使用*MonoBehaviour*时，所有事情都发生在幕后，这可不是一个好主意。拦截这种行为会产生很多问题。 

## 你对于可测试性

最后都是关于你，以及你是多么有动力去编写可测试代码的。许多方法可以解决同样的问题，但只有少数方法可以很好地用于测试自动化。如果你想编写可测试的代码，有时你需要编写比你想象的更多的代码。如果你仍然在学习（难道我们不应该在我们的人生中不断学习吗？）或者刚刚进入测试自动化冒险之路，你可能会发现一些代码段或设计假设是不必要的开销。然而，这些习惯如此迅速地变成了一种习惯，当你开始使用pro-automation设计时，甚至没有想到它，你甚至都不会注意到它。 

在这篇文章中，我将向你展示一种设计*MonoBehaviour*的方法，以便能够在之后进行测试。这并不完全正确，因为我们不会自己测试*MonoBehaviours*。您可能已经对如何在设计中实施Humble Object模式以使其更具可测性有所了解，但是，让我向你展示在真实项目中实施这个想法。 

## 示例

我们为这个例子创建一个用例。假设一个有简单的玩家控制器用来负责操控一个飞船。为了简化这个例子，我们使用2D空间。我们想要这个飞船可以在每个方向飞来飞去。它有可以直线发射子弹的枪（太空火箭？）但不会比给定的射速更频繁。子弹的数量也受到弹仓容量的限制，所以一旦你射击了所有子弹，你需要重新加载。为了让它更有趣，让我们使运动速度取决于飞船的血量。 

一个用来控制我们飞船的*Monobehaviour* 就像这样：

![img](https://blogs.unity3d.com/wp-content/uploads/2014/06/example1.png) 

在*FixedUpdate*回调中，我们读取输入并根据用户按下的按钮执行操作。为了移动飞船，我们需要将根据轴位置的速度常量转化为飞船的位置。正如你在代码中看到的那样，*deltaX*和*deltaY*变量是乘以*Time.fixedDeltaTime*后的结果，这个值来自输入轴以及本身依赖于血量的速度常量。 

在*Fire1*事件中（例如点击鼠标左键），我们要检查是否可以发射子弹。首先，我们需要至少一颗子弹在子弹仓中。其次，我们只想让飞船以一定的速度射击（在这个例子中每半秒一次）。因此，我们检查自从最后一颗子弹发射以来已过去多少时间。如果都可以，我们会产生子弹。 

*Fire2* 事件将简单的重新填满弹仓。

要为这个逻辑编写单元测试，我们需要克服两个问题。第一个，就像前面提到的，是我们通过继承依赖的不可模拟的*MonoBehaviour*类。第二个问题是在实时软件中更普遍的。我们的逻辑取决于时间（开火速率），这使得不可能执行单元测试，因为我们不能截获Unity中的静态时间类。好消息是所有这些都可以解决。 

让我们通过应用一些简单的方法提取重构来重构我们的代码，并牢记逻辑方法不应该引用Unity API（在这个例子中，输入处理和子弹实例化）。 if语句中的时间依赖关系也应该提取到单独的方法中。最终的结果应该看起来或多或少像这样： 

![example2](https://blogs.unity3d.com/wp-content/uploads/2014/06/example2.png) 

正如你所看到的，这里的*FixedUpdate*方法只不过是将用户的输入传递给逻辑部分的方法。开火速率检查被提取到*CanFire*方法，如果经过了指定的时间结果为“true”。这个提取很重要，因为它可以让我们稍后编写单元测试。如果我们现在可以模拟*SpaceshipMotor*类，那么无论何时只要我们，我们就可以简单地将*CanFire*方法截获并使其返回true或false。这将使测试与时间无关。但是因为它继承了*Monobehaviour*，我们不能模拟*SpaceshipMotor*，所以我们需要应用Humble Object模式。 

我们如何做到这一点？我们只需要将不使用Unity API的所有逻辑代码提取到单独的类，并将其引用到*SpaceshipMotor*。我们再来看看这个类要提取什么。 *TranformPosition*和*InstanciateBullet*使用Unity API，但其他所有内容都可以提取。我知道还有静态的*Time*类，但让我稍后再来看。

在我们进行实际提取之前剩下的最后一件事就是提取的逻辑如何与Unity API进行通信而不依赖于它。这是接口该来的地方。具有逻辑的类将有一个接口的引用，我不会关心实际的实现。为了简单起见，我们可以直接在*MonoBehaviour*中实现这些接口！我们来看看下面的两个类：  

![Example3](https://blogs.unity3d.com/wp-content/uploads/2014/06/example31.png) 

![Example4](https://blogs.unity3d.com/wp-content/uploads/2014/06/example41.png) 

我们从*SpaceshipMotor*类开始。该类实现了一些接口，分别负责转换飞船的位置和实例化子弹。该类本身有一个引用*SpaceshipController*的字段，该字段现在实现了所有的逻辑。 *SpaceshipController*类对*SpaceshipMotor*一无所知，它唯一能做的就是从它引用的接口调用方法。 

Unity不会序列化对接口的引用。如果你不关心序列化，只需在构造*SpaceshipController*类时传递接口引用即可。除此以外，你可以在序列化发生后每次调用的*OnEnable*回调中设置引用。只是为了记录，整个*SpaceshipMotor*类将按照通常的方式进行序列化，只是接口引用会丢失。 

你必须注意到*SpaceshipMotor*中的*Time*类的引用。我知道我说过在这里应该没有Unity API参考，但是我将它留在那里是为了演示不同的方法处理依赖于时间的依赖关系。理想情况下，我们可以简单地将*Time.time*值作为参数传递给方法。 

对于UML粉丝来说，这是（简化的）UML图的最终结果： 

![example-uml1](https://blogs.unity3d.com/wp-content/uploads/2014/06/example-uml13.png) 

### 单元测试

通过解耦*SpaceshipMotor*类，已经没有什么可以组织我们来写一些单元测试了。看下其中一个测试： 

![Example5](https://blogs.unity3d.com/wp-content/uploads/2014/06/example5.png) 

如果你没有子弹，测试证明你不能射击。测试本身是根据Arrange-Act-Assert模式构造的。在排列部分，我们使用*GetGunMock*和*GetControllerMock*方法创建对象模拟。 *GetControllerMock*除了创建一个模拟外，还会重写*CanFire*方法的行为始终返回true。这将从控制器对象中移除对时间的依赖。接下来，我们将当前的子弹编号设置为0.之后，我们将开火应用于控制器类，并且我们断言如果在枪控制器接口上尚未调用*Fire*。 

该项目中还有几个测试。你可以从[这里](https://oc.unity3d.com/public.php?service=files&t=8a5d2398dc85254dd2497fed74a38ce4)获得它并试一下。我用*NSubstitute*来模拟对象。我们还发布了一个[Unity Test Tools](https://www.assetstore.unity3d.com/en/#!/content/13802)的版本。我们在这里讨论的控制器的所有三个版本都附在项目中。 这就是我今天带来的。我希望你喜欢读这篇文章并且快乐的测试！ 

Tomek 
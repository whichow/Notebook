> 如果你是开发人员，你应该已经听说过单元测试。你们中的大多数人甚至可能都写过。但是你们中有多少人曾经考虑过什么样的单元测试才是一个好的单元测试？单元测试框架只是（相当）简单的一个接一个地调用一系列方法。但是实际要在该方法中执行的代码框架并不关心。只需双击它即可拥有一份您最喜爱的比萨饼列表，并提供送货上门的选项是多么惬意。为什么不使用单元测试框架来列出所有选项并节省编写GUI的时间！这是否意味着您有用于制作披萨订单的测试套件？ 

单元测试框架只是编写测试的工具，但并不是每个在这个框架中编写的测试都将是一个（适当的）单元测试。 让我们来解释比萨饼的例子，想象一下你想要测试的比萨饼的订购系统。 这个测试用例是应该验证当我按下“Make the order”按钮时调用生成了。 最直接的解决方案是模拟测试中的所有步骤，但每次运行测试时都不会真的想要收到比萨饼，是吗？

#### 那么这个测试有什么问题？

我们从测试的范围开始。顾名思义，单元测试应该测试一个工作单元。有些人把工作单元定义为一种方法，但是这个定义是相当有限的，最好将一个工作单元看作一个**单一的逻辑概念**。测试不应该与比萨店进行实际交流并进行订购。相反，一旦按下按钮，您将测试是否有正确的订单消息从系统中发出。 

#### 我改该怎样验证？

让我们假设比萨店有一个在线系统接受订单，我们的应用程序必须发送一个HTTP请求来订购比萨饼。由于我们不想实际订购比萨饼，我们可以创建自己的服务器（测试服），以模拟原始服务器的行为，但不发送真正的比萨饼。这种方法不会那么糟糕，但它使我们的单元测试依赖于外部资源和网络通信。另外，我们如何知道我们的模拟服务器是是否和原始服务器工作一致。或者只是可以工作？我们不应该测试模拟服务器吗？不！你不应使用模拟服务器，而应该在较低级别进行验证。您应该验证负责网络通信的对象是否会调用服务器而是真的去调用。通过调用，我的意思是HTTP请求。代码中发生了调用，并且它的响应是伪造的（基本上，测试模块中的代码不应与生产中使用的代码不同）。我们希望**在内存中运行测试**，而不使用任何资源。为了达到这个目的，我们需要使用模拟框架来模拟一些对象，或者为了测试目的创建特殊的实现。 

使用接口解耦你的模块！

![Pizza order example](https://blogs.unity3d.com/wp-content/uploads/2014/05/pizza-example2.png) 

#### 如果使用第三方支付系统该怎么办？

支付系统将我们连接到一个第三方网站并期望我们输入你的信用卡号是一个真正的预算杀手。我们无疑想要跳过这个步骤，不仅仅是因为我们可以不用背负巨额的信用卡债务，而且我们还希望通过每次执行测试时不输入信用卡号来节省自己的时间 。我们当然可以‘雇佣’一个学生来为我们做这个工作（并让他获得宝贵的经验）或者我们可以对此做出明智的决定。一个真正的单元测试应该是**完全自动化的**。不需要人为干预。我们可以简单地通过再次使用模拟对象来实现我们想要的。模拟让我们可以覆盖系统某些部分的行为，这使得我们可以简化和跳过订购过程中的某些步骤。在这种情况下，我们模拟我们的付款模块，并告诉它立即确认我们的付款，而无需将我们重定向到任何地方。另外，它使我们能够**完全控制测试**。想象一下，如果第三方服务器没有响应或变得超级慢，我们所有的测试套件都会因此而失败。

一个披萨订购测试的简单例子：

![Pizza order test](https://blogs.unity3d.com/wp-content/uploads/2014/05/pizza-example.png) 

#### 太好了...还有什么？ 

还有更多的东西可以使你的测试更好，这与单元测试没有直接关系。**可读性**和可维护性将使得后面接手测试的人非常容易的介入并做一些更改。可读测试还可以作为你的功能的内部文档。花在写文档上的时间减少了，你可以有更多的时间来编写测试！ 

永远不要使你的测试相互依赖。测试的顺序从来就不重要！这会使得测试很难调试和维护。如果一个测试只是因为依赖于前一个测试而导致失败了，那么代码的真实状态会被误导性的结果所掩盖。在测试之间共享设置，但始终**使测试彼此独立**。 

最后但并非最不重要的是，您应该考虑执行时间。有些人喜欢将单元测试的执行视为编译过程的一部分。你不希望编译时间太长，所以你应该让你的单元测试运行得**很快**。 

### 总结

单元测试是你的通用测试套件的重要组成部分，应该成为所有类型测试的基础。要将这个想法可视化，请看一下测试金字塔（冰淇淋锥反模式的倒置概念），它描绘了测试项目中不同类型测试的健康分布。 

![pyramid](https://blogs.unity3d.com/wp-content/uploads/2014/05/pyramid-140x140-1400512554.png) 

#### 所以原来的比萨订购最后并没有那么糟糕？

不是必要的。我的观点是要展示什么是单元测试，什么不是。端到端场景也是自动化测试的一种选择，但不应将测试套件基于它们。在金字塔中走得越高，难以维护和调试的测试也越慢。集成测试和UI（雷击）测试也很重要，但这些都需要权衡。 

理论上都很好，但你现在可能会考虑它在Unity中如何应用。为了弥补性能，Unity具有一些不利于可测试的限制。缺乏界面序列化是其中之一。但并非所有的代码都需要被序列化！我将在未来撰写有关这些限制的解决方法。 

下一篇文章是关于设计具有可测试性的MonoBehaviour。敬请关注！ 